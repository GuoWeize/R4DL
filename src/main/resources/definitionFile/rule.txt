function listInclude (list, list) {
    all (b in %2%) {
        any (a in %1%) {
            equal(a, b);
        }
    }
}

function listEqual (list, list) {
    and {
        listInclude(%1%, %2%);
        listInclude(%2%, %1%);
    }
}

function inoutInclude (Functional / condition, Functional / condition) {
    or {
        and {
            include(%1%.input, %2%.input);
            include(%1%.output, %2%.output);
        }
        and {
            include(%2%.input, %1%.input);
            include(%2%.output, %1%.output);
        }
    }
}

function baseContradict (Functional / condition, Functional / condition) {
    and {
        equal(%1%.agent, %2%.agent);
        contradict(%1%.operation, %2%.operation);
        inoutInclude(%1%, %2%);
    }
}

function baseInclude (Functional / condition, Functional / condition) {
    and {
        equal(%1%.agent, %2%.agent);
        include(%1%.operation, %2%.operation);
        include(%1%.input, %2%.input);
        include(%1%.output, %2%.output);
        include(%1%.restriction, %2%.restriction);
    }
}

function operationEventInterlock (Functional, Functional) {
    all (condition in %2%.event) {
        include(%1%.operation, condition);
    }
}

function inputOutputInterlock (Functional, Functional) {
    any (inEntity in %2%.input) {
        any (outEntity in %1%.output) {
            include(outEntity, inEntity);
        }
    }
}

function equal (entity, entity) {
    or {
        and {
            %1%.base == %2%.base;
            equal(%1%.modifier, %2%.modifier);
        }
        and {
            %1%.isAll;
            not {
                %2%.isAll;
            }
        }
        and {
            %2%.isAll;
            not {
                %1%.isAll;
            }
        }
    }
}

function equal (condition, condition) {
    equal(%1%.agent, %2%.agent);
    equal(%1%.operation, %2%.operation);
    equal(%1%.input, %2%.input);
    equal(%1%.output, %2%.output);
    equal(%1%.restriction, %2%.restriction);
}

function equal (operation, operation) {
    and {
        %1%.reaction == %2%.reaction;
        %1%.isAble == %2%.isAble;
        %1%.isNot == %2%.isNot;
    }
}

function equal (list, list) {
    listEqual(%1%, %2%);
}

function include (entity, entity) {
    or {
        and {
            %1%.base == %2%.base;
            listInclude(%2%.modifier, %1%.modifier);
        }
        equal(%1%, %2%.entirety);
    }
}

function include (operation, operation) {
    or {
        equal(%1%, %2%);
        and {
            %1%.reaction == %2%.reaction;
            %2%.isAble;
            not {
                %1%.isAble;
            }
        }
    }
}

function include (list, list) {
    listInclude(%1%, %2%);
}

function contradict (operation, operation) {
    and {
        %1%.reaction == %2%.reaction;
        not {
            %1%.isAble;
        }
        not {
            %2%.isAble;
        }
        not {
            %1%.isNot == %2%.isNot;
        }
    }
}

rule operationInconsistency (Functional, Functional) {
    and {
        equal(%1%.event, %2%.event);
        baseContradict(%1%, %2%);
    }
}

rule restrictionInconsistency (Functional, Functional) {
    and {
        equal(%1%.event, %2%.event);
        equal(%1%.agent, %2%.agent);
        equal(%1%.operation, %2%.operation);
        inoutInclude(%1%, %2%);
        not {
            equal(%1%.restriction, %2%.restriction);
        }
    }
}

rule eventInconsistency (Functional) {
    all (event1 in %1%.event) {
        any (event2 in %1%.event) {
            baseContradict(event1, event2);
        }
    }
}

rule operationInclusion (Functional, Functional) {
    and {
        equal(%1%.event, %2%.event);
        baseInclude(%1%, %2%);
    }
}

rule eventInclusion (Functional, Functional) {
    and {
        include(%1%.event, %2%.event);
        equal(%1%.agent, %2%.agent);
        equal(%1%.operation, %2%.operation);
        include(%1%.input, %2%.input);
        include(%1%.output, %2%.output);
        equal(%1%.restriction, %2%.restriction);
    }
}

rule operationEventInterlock (Functional ...) {
    all (%i%) {
        operationEventInterlock(%i%, %i+1%);
    }
}

rule inputOutputInterlock (Functional ...) {
    all (%i%) {
        inputOutputInterlock(%i%, %i+1%);
    }
}
